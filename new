// ==============================
// Imports
// ==============================
import io.opentelemetry.api.GlobalOpenTelemetry
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.api.common.Attributes

import io.opentelemetry.sdk.autoconfigure.AutoConfiguredOpenTelemetrySdk

// ==============================
// Initialize OpenTelemetry (AUTOCONFIGURE)
// ==============================
val autoSdk =
  AutoConfiguredOpenTelemetrySdk.builder()
    .build()

val openTelemetry = autoSdk.getOpenTelemetrySdk

// Make it global (important)
GlobalOpenTelemetry.set(openTelemetry)

// ==============================
// Create Tracer
// ==============================
val tracer: Tracer =
  GlobalOpenTelemetry.getTracer("databricks.custom.event")

println("OpenTelemetry initialized successfully")

// ==============================
// Send custom events (10 times)
// ==============================
for (i <- 1 to 10) {
  try {
    val span = tracer.spanBuilder(s"custom-operation-$i").startSpan()

    span.addEvent(
      "custom-event-start",
      Attributes.builder()
        .put("iteration", i)
        .put("source", "databricks")
        .build()
    )

    Thread.sleep(200)

    span.addEvent(
      "custom-event-end",
      Attributes.builder()
        .put("status", "success")
        .build()
    )

    span.end()

    println(s"Sent custom event iteration = $i")

  } catch {
    case e: Exception =>
      println(s"Error sending telemetry for iteration $i")
      e.printStackTrace()
  }
}

// ==============================
// Flush & shutdown (VERY IMPORTANT in Databricks)
// ==============================
autoSdk.getOpenTelemetrySdk.getSdkTracerProvider.forceFlush()
autoSdk.getOpenTelemetrySdk.getSdkTracerProvider.shutdown()

println("Telemetry flushed and shutdown complete")
