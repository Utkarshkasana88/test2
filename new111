Conversation opened. 1 unread message.

Skip to content
Using Gmail with screen readers
Enable desktop notifications for Gmail.
   OK  No thanks
1 of 185
Poc
Inbox

namrata kasana <kasananamrata017@gmail.com>
5:47â€¯PM (0 minutes ago)
to me

%scala
// ==============================
// Imports
// ==============================
import io.opentelemetry.api.{GlobalOpenTelemetry, OpenTelemetry}
import io.opentelemetry.api.trace.{Tracer, Span}
import io.opentelemetry.api.common.Attributes
import io.opentelemetry.sdk.autoconfigure.AutoConfiguredOpenTelemetrySdk
import com.azure.monitor.opentelemetry.autoconfigure.AzureMonitorAutoConfigure

import java.util.concurrent.TimeUnit

// ==============================
// CONFIGURATION
// ==============================

// Prefer environment variable in Databricks
// spark.conf.set("spark.databricks.env.APPLICATIONINSIGHTS_CONNECTION_STRING", "<your-connection-string>")

val CONNECTION_STRING =
sys.env.getOrElse(
"APPLICATIONINSIGHTS_CONNECTION_STRING",
throw new RuntimeException("APPLICATIONINSIGHTS_CONNECTION_STRING not set")
)

// ==============================
// OpenTelemetry + Azure Monitor Setup
// ==============================

val sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder()

// Attach Azure Monitor exporter
AzureMonitorAutoConfigure.customize(sdkBuilder, CONNECTION_STRING)

// Build SDK
val openTelemetrySdk = sdkBuilder.build().getOpenTelemetrySdk()

// Register globally (IMPORTANT)
GlobalOpenTelemetry.set(openTelemetrySdk)

// Ensure flush on Databricks job termination
sys.addShutdownHook {
openTelemetrySdk
.getSdkTracerProvider
.forceFlush()
.join(10, TimeUnit.SECONDS)
}

// ==============================
// Telemetry Data Model
// ==============================

case class NonNativeJobTelemetryData(
eventName: String,
properties: Map[String, String],
metrics: Map[String, Double],
status: String,
subSystem: Option[String]
)

// ==============================
// Sample Telemetry Payload
// ==============================

val telemetryData = NonNativeJobTelemetryData(
eventName = "nn_event",
properties = Map(
"component_name" -> "dbx-non-native-raw",
"source" -> "AT27359",
"last_updated_time" -> "2025-12-05 09:36:53 UTC",
"status" -> "DONE",
"sub_system" -> "non-native"
),
metrics = Map(
"elapsed" -> 390050.0
),
status = "DONE",
subSystem = Some("non-native")
)

// ==============================
// Tracer
// ==============================

val tracer: Tracer =
openTelemetrySdk.getTracer("custom-event-tracer")

// ==============================
// Send Custom Event
// ==============================

def sendCustomEvent(data: NonNativeJobTelemetryData): Unit = {

val attrBuilder = Attributes.builder()

// Add properties
data.properties.foreach {
case (k, v) => attrBuilder.put(k, v)
}

// Add metrics
data.metrics.foreach {
case (k, v) => attrBuilder.put(k, v)
}

// Add top-level attributes
attrBuilder.put("job_status", data.status)
attrBuilder.put("sub_system", data.subSystem.getOrElse("unknown"))

val attributes = attrBuilder.build()

val span: Span =
tracer
.spanBuilder(data.eventName)
.setAllAttributes(attributes)
.startSpan()

// End immediately (event-style span)
span.end()
}

// ==============================
// Emit Telemetry
// ==============================

sendCustomEvent(telemetryData)

println("Custom telemetry event sent to Azure Application Insights")
