// =======================================
// Imports
// =======================================
import io.opentelemetry.api.GlobalOpenTelemetry
import io.opentelemetry.api.trace.{Tracer, Span}
import io.opentelemetry.api.common.Attributes
import io.opentelemetry.sdk.autoconfigure.AutoConfiguredOpenTelemetrySdk

import com.azure.monitor.opentelemetry.autoconfigure.AzureMonitorAutoConfigure

import java.util.concurrent.TimeUnit

// =======================================
// Read Connection String
// =======================================
val CONNECTION_STRING =
  sys.env.getOrElse(
    "APPLICATIONINSIGHTS_CONNECTION_STRING",
    throw new RuntimeException("APPLICATIONINSIGHTS_CONNECTION_STRING not set")
  )

// =======================================
// OpenTelemetry + Azure Monitor setup
// =======================================
println("Initializing OpenTelemetry with Azure Monitor...")

val sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder()

// ✅ REQUIRED: Azure Monitor customization
AzureMonitorAutoConfigure.customize(sdkBuilder, CONNECTION_STRING)

// Build SDK
val openTelemetrySdk =
  sdkBuilder.build().getOpenTelemetrySdk()

// Register globally
GlobalOpenTelemetry.set(openTelemetrySdk)

println(
  "OpenTelemetry initialized: " +
    GlobalOpenTelemetry.get().getClass.getName
)

// =======================================
// Flush on Databricks shutdown
// =======================================
sys.addShutdownHook {
  println("Flushing telemetry...")
  try {
    openTelemetrySdk
      .getSdkTracerProvider
      .forceFlush()
      .join(10, TimeUnit.SECONDS)

    openTelemetrySdk
      .getSdkTracerProvider
      .shutdown()
  } catch {
    case e: Throwable =>
      println("Flush failed: " + e.getMessage)
  }
}

// =======================================
// Telemetry data model
// =======================================
case class CustomEventData(
  eventName: String,
  properties: Map[String, String],
  metrics: Map[String, Double]
)

// =======================================
// Sample payload
// =======================================
val eventData = CustomEventData(
  eventName = "nn_event",
  properties = Map(
    "component_name" -> "dbx-non-native-raw",
    "source" -> "AT27359",
    "status" -> "DONE",
    "sub_system" -> "non-native"
  ),
  metrics = Map(
    "elapsed_ms" -> 390050.0,
    "records_processed" -> 1200.0
  )
)

// =======================================
// Tracer
// =======================================
val tracer: Tracer =
  GlobalOpenTelemetry.get()
    .getTracer("databricks.custom.event")

// =======================================
// Send CUSTOM EVENT (App Insights customEvents)
// =======================================
def sendCustomEvent(data: CustomEventData): Unit = {

  println(s"Sending custom event: ${data.eventName}")

  val attributesBuilder = Attributes.builder()

  // Properties → customDimensions
  data.properties.foreach {
    case (k, v) => attributesBuilder.put(k, v)
  }

  // Metrics → customMeasurements
  data.metrics.foreach {
    case (k, v) => attributesBuilder.put(k, v)
  }

  val attributes = attributesBuilder.build()

  // Parent span (required)
  val span: Span =
    tracer.spanBuilder("event-parent-span").startSpan()

  try {
    // ✅ This creates Application Insights customEvent
    span.addEvent(data.eventName, attributes)
  } catch {
    case e: Exception =>
      span.recordException(e)
      throw e
  } finally {
    span.end()
  }

  println("Custom event sent successfully")
}

// =======================================
// Emit telemetry
// =======================================
sendCustomEvent(eventData)

println("Done")
